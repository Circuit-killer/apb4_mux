<h1 id="introduction">Introduction</h1>
<p>The <em>AMBA APB v2.0</em> bus protocol - commonly referred to as APB4 - defines a low-cost interface that is optimized for minimal power consumption and reduced interface complexity. To enable a single APB4 Master to communicate with <em>multiple</em> APB4 Slaves (Peripherals) via a common bus, certain signals require multiplexing – the Roa Logic APB4 Multiplexer is a fully configurable &amp; parameterized IP to provide this functionality as shown below:</p>
<div class="figure">
<img src="assets/img/APB4-Mux-Sys.png" alt="APB4 Multiplexer System" />
<p class="caption">APB4 Multiplexer System<span data-label="fig:apb4-mux-sys"></span></p>
</div>
<h2 id="features">Features</h2>
<ul>
<li><p>Full support for <em>APB version 2.0</em> (APB4) protocol</p></li>
<li><p>Fully parameterized IP with:</p>
<ul>
<li><p>User Configurable number of peripherals supported</p></li>
<li><p>User Configurable address and data widths</p></li>
</ul></li>
<li><p>Support for user defined address mapping per peripheral</p></li>
</ul>
<h1 id="specifications">Specifications</h1>
<h2 id="functional-description">Functional Description</h2>
<p>The Roa Logic APB4 Multiplexer is a highly configurable, fully parameterized soft IP to enable a single APB4 based Master (Host) to communicate with multiple APB4 Slaves (Peripherals). It is fully compliant with the <em>AMBA APB v2.0</em> bus protocols.</p>
<p>The IP contains a single Master Interface to connect to the APB4 Host, and a user defined number of Slave Interfaces.</p>
<p>The multiplexer functions as follows:</p>
<ul>
<li><p>Transactions on the APB4 Bus are decoded by matching addresses on the APB4 address bus to an address map defined by the <code>SLV_ADDR[n]</code> and <code>SLV_MASK[n]</code> inputs of the multiplexer</p></li>
<li><p>Communication with a peripheral is enabled by asserting the appropriate <code>SLV_PSEL[n]</code> output signal based on the address mapping (See section 4.3.1)</p></li>
<li><p>Peripheral-specific control signals <code>SLV_PSLVERR[n]</code>and <code>SLV_READY[n]</code>, together with the Read Data Bus signals <code>SLV_PRDATA[n]</code> during a read transaction, are then multiplexed back to the Master Interface.</p></li>
</ul>
<h2 id="master-interface">Master Interface</h2>
<p>The APB4 Multiplexer Master Interface consists of the following subset of APB4 bus signals:</p>
<ul>
<li><p><code>PADDR</code> and <code>PSEL</code> inputs to enable address space decoding</p></li>
<li><p><code>PREADY</code> and <code>PSLVERR</code> outputs derived from the selected peripheral</p></li>
<li><p><code>PRDATA</code> read data bus output derived from the selected peripheral during a read transaction</p></li>
</ul>
<p>All other APB4 bus signals are connected directly to each peripheral</p>
<h2 id="slave-interfaces">Slave Interfaces</h2>
<p>The APB4 Multiplexer generates a user-defined number (‘n’) of Slave Interfaces that consist of the following subset of APB4 bus signals:</p>
<ul>
<li><p><code>PSEL[n]</code> outputs used to select an individual peripheral during a transaction</p></li>
<li><p><code>PREADY[n]</code> and <code>PSLVERR[n]</code> control signal inputs from each peripheral which are multiplexed as outputs on the Master Interface</p></li>
<li><p><code>PRDATA[n]</code> read data bus inputs from each peripheral which is multiplexed to the Master Interface</p></li>
</ul>
<h2 id="address-space-configuration">Address Space Configuration</h2>
<p>Each Slave Port has an Address Base (<code>SLV_ADDR[n]</code>) and Address Mask (<code>SLV_MASK[n]</code>) port. Together these set the address range covered by each Slave Port. (See section 4.3.5)</p>
<p><img src="assets/img/APB4-Mux-Sig.png" alt="image" /></p>
<p>While the Address Base and Address Mask values may be changed dynamically, assigning static values according to a predefined address map is typical.</p>
<h1 id="configurations">Configurations</h1>
<h2 id="introduction-1">Introduction</h2>
<p>The Roa Logic APB4 Multiplexer is a fully configurable interconnect IP to enable an APB4 Master to communicate with multiple APB4 slaves (i.e. peripherals). The core parameters and configuration options are described below.</p>
<table>
<caption>Core Parameters</caption>
<thead>
<tr class="header">
<th align="left">Parameter</th>
<th align="center">Type</th>
<th align="center">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>SLAVES</code></td>
<td align="center">Integer</td>
<td align="center">8</td>
<td align="left">Number of attached slaves (peripherals)</td>
</tr>
<tr class="even">
<td align="left"><code>PADDR_SIZE</code></td>
<td align="center">Integer</td>
<td align="center">8</td>
<td align="left">Address Bus Width</td>
</tr>
<tr class="odd">
<td align="left"><code>PDATA_SIZE</code></td>
<td align="center">Integer</td>
<td align="center">8</td>
<td align="left">Read Data Bus Width</td>
</tr>
</tbody>
</table>
<h3 id="slaves">SLAVES</h3>
<p>The <code>SLAVES</code> parameter specifies the number of slaves (i.e. peripherals) the APB4 Multiplexer will support.</p>
<h3 id="paddr_size">PADDR_SIZE</h3>
<p>The <code>PADDR_SIZE</code> parameter specifies the width of the address bus for the APB4 Interfaces. The Master and all peripherals sharing the APB4 Multiplexer are expected to have the same address width.</p>
<h3 id="pdata_size">PDATA_SIZE</h3>
<p>The <code>PDATA_SIZE</code> parameter specifies the width of the APB4 data bus. This parameter must equal an integer multiple of bytes. The Master and all peripherals sharing the APB4 Multiplexer are expected to have the same data width.</p>
<h1 id="interfaces">Interfaces</h1>
<h2 id="global-signals">Global Signals</h2>
<p>The following common signals are shared between all devices on the APB4 bus.</p>
<table>
<caption>Global Signals</caption>
<thead>
<tr class="header">
<th align="left">Port</th>
<th align="center">Size</th>
<th align="center">Direction</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>PRESETn</code></td>
<td align="center">1</td>
<td align="center">Input</td>
<td align="left">Asynchronous active low reset</td>
</tr>
<tr class="even">
<td align="left"><code>PCLK</code></td>
<td align="center">1</td>
<td align="center">Input</td>
<td align="left">Clock Input</td>
</tr>
</tbody>
</table>
<h3 id="presetn">PRESETn</h3>
<p>When the active low asynchronous <code>PRESETn</code> input is asserted (‘0’), the APB4 interface is put into its initial reset state.</p>
<h3 id="pclk">PCLK</h3>
<p><code>PCLK</code> is the APB4 interface system clock. All internal logic for the APB4 interface operates at the rising edge of this system clock and APB4 bus timings are related to the rising edge of <code>PCLK</code>.</p>
<h2 id="master-interface-1">Master Interface</h2>
<p>The APB4 Interface decodes the signaling of an APB4 bus master and therefore implements a subset of a regular APB4 Slave Interface.</p>
<table>
<caption>APB4 Master Interface Ports</caption>
<thead>
<tr class="header">
<th align="left">Port</th>
<th align="center">Size</th>
<th align="center">Direction</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>MST_PSEL</code></td>
<td align="center">1</td>
<td align="center">Input</td>
<td align="left">Peripheral Select</td>
</tr>
<tr class="even">
<td align="left"><code>MST_PADDR</code></td>
<td align="center"><code>PADDR_SIZE</code></td>
<td align="center">Input</td>
<td align="left">Address Bus</td>
</tr>
<tr class="odd">
<td align="left"><code>MST_PRDATA</code></td>
<td align="center"><code>PDATA_SIZE</code></td>
<td align="center">Output</td>
<td align="left">Read Data Bus</td>
</tr>
<tr class="even">
<td align="left"><code>MST_PREADY</code></td>
<td align="center">1</td>
<td align="center">Output</td>
<td align="left">Transfer Ready</td>
</tr>
<tr class="odd">
<td align="left"><code>MST_PSLVERR</code></td>
<td align="center">1</td>
<td align="center">Output</td>
<td align="left">Transfer Error Indicator</td>
</tr>
</tbody>
</table>
<h3 id="mst_psel">MST_PSEL</h3>
<p>it is selected and a data transfer is pending. This signal drives the APB4 Multiplexer MST_PSEL port and is decoded to select the individual peripheral by asserting the corresponding <code>SLV_PSEL[n]</code> output..</p>
<h3 id="mst_paddr">MST_PADDR</h3>
<p><code>MST_PADDR</code> is the APB4 address bus. The bus width is defined by the <code>PADDR_SIZE</code> parameter and is driven by the APB4 Master.</p>
<h3 id="mst_prdata">MST_PRDATA</h3>
<p><code>MST_PRDATA</code> drives the APB4 read data bus. The selected peripheral drives this bus during read cycles, via the APB4 Multiplexer.</p>
<p>The bus width must be byte-aligned and is defined by the <code>PDATA_SIZE</code> parameter.</p>
<h3 id="mst_pready">MST_PREADY</h3>
<p><code>MST_PREADY</code> is driven by the selected peripheral via the APB4 Multiplexer. It is used to extend an APB4 transfer.</p>
<h3 id="mst_pslverr">MST_PSLVERR</h3>
<p><code>MST_PSLVERR</code> indicates a failed data transfer to the APB4 Master when asserted (‘1’) and is driven by the selected peripheral via the APB4 Multiplexer.</p>
<h2 id="slave-interface">Slave Interface</h2>
<p>The Slave Interface provides the following signals <em>for each</em> individual peripheral. The number of peripherals supported, and therefore instances of the following signals, is controlled by the SLAVES parameter (see section 0).</p>
<blockquote>
<p><strong>Note:</strong> Each individual port name is referenced by the index ‘n’, where ‘n’ is an integer value in the range 0 to <code>SLAVES-1</code>. E.g. <code>SLV_PSEL[2]</code> This nomenclature is used throughout this datasheet</p>
</blockquote>
<table>
<caption>Slave Interface Ports</caption>
<thead>
<tr class="header">
<th align="left">Port</th>
<th align="center">Size</th>
<th align="center">Direction</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>SLV_PSEL[n]</code></td>
<td align="center">1</td>
<td align="center">Output</td>
<td align="left">Peripheral Select</td>
</tr>
<tr class="even">
<td align="left"><code>SLV_PRDATA[n]</code></td>
<td align="center"><code>PDATA_SIZE</code></td>
<td align="center">Input</td>
<td align="left">Read Data Bus</td>
</tr>
<tr class="odd">
<td align="left"><code>SLV_PREADY[n]</code></td>
<td align="center">1</td>
<td align="center">Input</td>
<td align="left">Transfer Ready Input</td>
</tr>
<tr class="even">
<td align="left"><code>SLV_PSLVERR[n]</code></td>
<td align="center">1</td>
<td align="center">Input</td>
<td align="left">Transfer Error Indicator</td>
</tr>
<tr class="odd">
<td align="left"><code>SLV_ADDR[n]</code></td>
<td align="center"><code>PADDR_SIZE</code></td>
<td align="center">Input</td>
<td align="left">Transfer Ready Input</td>
</tr>
<tr class="even">
<td align="left"><code>SLV_MASK[n]</code></td>
<td align="center"><code>PADDR_SIZE</code></td>
<td align="center">Input</td>
<td align="left">Transfer Error Indicator</td>
</tr>
</tbody>
</table>
<h3 id="slv_pseln">SLV_PSEL[n]</h3>
<p>The APB4 Multiplexer generates <code>SLV_PSEL[n]</code>, signaling to an attached peripheral that it is selected and a data transfer is pending.</p>
<h3 id="slv_prdatan">SLV_PRDATA[n]</h3>
<p><code>SLV_PRDATA[n]</code> is the APB4 read data bus associated with the attached peripheral. The peripheral drives this bus during read cycles, indicated when <code>PWRITE</code> is negated (‘0’), and the data is then multiplexed to the <code>MST_PRDATA</code> output port.</p>
<p>The bus width must be byte-aligned and is defined by the <code>PDATA_SIZE</code> parameter.</p>
<h3 id="slv_preadyn">SLV_PREADY[n]</h3>
<p><code>SLV_PREADY[n]</code> is driven by the attached peripheral and multiplexed to the <code>MST_PREADY </code>output port. It is used to extend an APB4 transfer.</p>
<h3 id="slv_pslverrn">SLV_PSLVERR[n]</h3>
<p><code>SLV_PSLVERR[n]</code> indicates a failed data transfer when asserted (‘1’). As APB4 peripherals are not required to support this signal it must be tied LOW (‘0’) when unused.</p>
<h3 id="slv_addrn-and-slv_maskn">SLV_ADDR[n] and SLV_MASK[n]</h3>
<p><code>SLV_ADDR[n]</code> is the base address where the attached peripheral is to appear in the system memory map. It is bitwise ‘AND’ed with the corresponding address mask <code>SLV_MASK[n]</code> input to define the overall address range of each peripheral.</p>
<p>As a consequence, these ports are typically assigned hard-coded values rather than connected to other logic in the design.</p>
<h1 id="resources">Resources</h1>
<p>Below are some example implementations for various platforms. All implementations are push button, no effort has been undertaken to reduce area or improve performance.</p>
<table>
<caption>Resource Utilization Examples</caption>
<thead>
<tr class="header">
<th align="left">Platform</th>
<th align="left">DFF</th>
<th align="left">Logic Cells</th>
<th align="left">Memory</th>
<th align="left">Configuration</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><p>Cyclone-IV</p></td>
<td align="left"><p>0</p></td>
<td align="left"><p>84</p></td>
<td align="left"><p>0</p></td>
<td align="left"><p><code>SLAVES=23</code>, <code>PADDR_SIZE=16</code>, <code>PDATA_SIZE=8</code></p></td>
</tr>
</tbody>
</table>
<h1 id="references">References</h1>
<h1 id="revision-history">Revision History</h1>
<table>
<caption>Revision History</caption>
<thead>
<tr class="header">
<th align="left">Date</th>
<th align="left">Rev.</th>
<th align="left">Comments</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">01-Feb-2017</td>
<td align="left">1.0</td>
<td align="left">Initial Release</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
